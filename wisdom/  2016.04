2016.04.19

Agile Software Development Principles, Patterns, and Practices - Robert C.Martin
1、测试优先
	1、除非缺乏某个功能将导致测试失败，否则就拒绝实现该功能。
	2、除非由于缺少某行代码将导致测试失败，否这就拒绝增加哪怕一行代码。
	3、如果首先编写失败的测试表明需要一项功能，然后再逐渐的增加那项功能使测试通过。

2、测试优先的优点：
	1、程序中的每一项功能都有测试来验证它的操作的正确性。无论何时我们因疏忽破坏了某些已有功能,它就会告诉我们。
	2、首先编写测试可以迫使我们使用不同的观察点。我们必须从程序调用者的有利视角取观察我们将要编写的程序。这样，我们在关注程序功能的同时，直接关注它的接口。
	3、测试可以作为一种物价的文档形式。测试会展示给你如何调用一个函数或者创建一个对象。
	4、测试促使模块之间隔离，先编写测试常常会暴露程序中应该被解耦合的区域。

3、单元测试是用来验证系统中个别机制的白盒测试，验收测试是用来验证系统满足客户需求的黑盒测试。

4、为了使一个模块或程序具有可测试性，必须要对它解耦合。越是具有可测试性，耦合关系就越弱。

2016.04.20

1、设计的臭味 - 腐化软件的气味
	僵化性（Rigidity）：很难队系统进行改动，因为每个改动都会迫使许多队系统其他部分的改动。
	脆弱性（Fragility）：队系统的改动会导致系统中和改动的地方在概念上无关的许多地方出现问题。
	牢固性（Immobility）：很难解开系统的纠结，使之成为一些可在其他系统重用的组件。
	粘滞性（Viscosity）：做正确的事情比做错误的事情要困难。
	不必要的复杂性（Neddless Complexity）：设计中包含有不具任何直接好处的基础结构。
	不必要的重复（Needless Repetition）：设计中包含有重复的结构，而该重复的结构本可以使用单一的抽象进行统一。
	晦涩性（Opacity）：很难阅读、理解。没有很好的表现出意图。

2、单一职责原则
	就一个类而言，应该仅有一个引起它变化的原因。
	如果一个类承担的责任过多，就等于把这些职责耦合在了一起。
	如果你能想到多余一个的动机去改变一个类，那么这个类就具有多余一个职责。
	如果应用程序的变化方式总是导致这两个职责同时变化，那么就不必分离它们。

3、开放-封闭原则
	软件的实体（类、模块、函数等）应该是可以扩展的，但是不可修改的。

2016.04.21
1、开放-封闭原则 ***关键是抽象，通过抽象来隔离不同***  封闭是建立在抽象的基础之上的。
	对于扩展是开放的 - 程序可以扩展。
	对于修改是封闭的 - 程序扩展时，通过添加新的代码实现（例如创建一个新的派生类，并实现它的所有函数），而不更改现有的代码。

2、预测变化和“贴切的”结构
	没有对于所有情况都贴切的模型。因此，模块无法做到完全“封闭”。
	设计人员必须对模块应对那种变化封闭作出选择。

3、只受一次愚弄
	为了防止软件不必要的复杂性，我们允许自己被愚弄一次。者意味着我们在最初编写代码时，假设变化不会发生。当发生变化时，我们就创建抽象来隔离以后发生同样的变化。

4、刺激变化
	变化出现的越早，损失越小。

2016.04.25

1、替换原则（LSP: The Liskov Substitution Principle）
	子类型必须能够替换掉它们的基类型。
	假设一个函数f，它的参数为基类B的指针或者引用（reference）。假设B有派生类D，如果吧D的对象作为B类型传递给f，会导致f出错。那么D就违反了LSP。
	对象的行为才是软件真正所关注的问题。

2、基于契约设计（DBC: Design By Contract）
	契约是通过为每个方法声明前置条件和后置条件来指定的。
	在派生类中，只能使用相等或更弱的前置条件，只能使用相等或更强的后置条件。

3、违反LSP的方式
	派生类中的退化函数
	派生类中抛出基类不会抛出的异常。

4、依赖倒置（DIP: Dependence Inversion Principle）
	A.高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。
	B.抽象不应该依赖于具体实现，具体实现应该依赖于抽象

	倒置不仅仅是关系的倒置，它也是接口所有权的倒置。（Don't call us, we'll call you.）底层模块实现了在高层模块中声明并被高层模块调用的接口。

	








































